\chapterAndLabel{Modifiability Checker}{modifiability-checker}

The Modifiability Checker issues a warning, at compile time, if a program might
throw \code{UnsupportedOperationException} at run time due to invoking a
mutating method (such as \code{add} or \code{remove}) on an unmodifiable
collection, map, or iterator.
(This chapter generally uses just ``collection'', for brevity.)

% MDE: TODO
In Java, an \emp{optional} method is one

An \emph{unmodifiable collection} is one that throws
\code{UnsupportedOperationException} if a mutating method is called.
The JDK provides many such collections, for example, the results of:
\begin{itemize}
\item
  \sunjavadoc{java.base/java/util/List.html\#of(E...)}{\code{List.of()}},
  \sunjavadoc{java.base/java/util/List.html\#copyOf(java.util.Collection)}{\code{List.copyOf()}}
\item
  \sunjavadoc{java.base/java/util/Set.html\#of(E...)}{\code{Set.of()}},
  \sunjavadoc{java.base/java/util/Set.html\#copyOf(java.util.Collection)}{\code{Set.copyOf()}}
\item
  \sunjavadoc{java.base/java/util/Map.html\#of(K,V,K,V)}{\code{Map.of()}},
  \sunjavadoc{java.base/java/util/Map.html\#copyOf(java.util.Map)}{\code{Map.copyOf()}}
\item
  \sunjavadoc{java/util/Collections.html\#emptyList()}{\code{Collections.emptyList()}}
  \sunjavadoc{java/util/Collections.html\#emptySet()}{\code{Collections.emptySet()}}
  \sunjavadoc{java/util/Collections.html\#emptyMap()}{\code{Collections.emptyMap()}}
\item
  \sunjavadoc{java.base/java/util/Collections.html\#unmodifiableList(java.util.List)}{\code{Collections.unmodifiableList()}}
  \sunjavadoc{java.base/java/util/Collections.html\#unmodifiableSet(java.util.Set)}{\code{Collections.unmodifiableSet()}}
  \sunjavadoc{java.base/java/util/Collections.html\#unmodifiableMap(java.util.Map)}{\code{Collections.unmodifiableMap()}}
\end{itemize}

A \emph{modifiable collection} is one on which mutating methods can be called
without throwing \code{UnsupportedOperationException}.  Many other methods, such
as \code{get}, \code{contains}, \code{isEmpty}, and \code{toArray}, may be
called on any collection, whether modifiable or unmodifiable.

A collection can be modified in three different ways:
\textbf{Grow}, \textbf{Shrink}, and \textbf{Replace}.
\begin{itemize}
    \item \textbf{Grow (G)}: The collection can grow by adding new elements
      (\<add>, \<addAll>, \ldots).
    \item \textbf{Shrink (S)}: The collection can shrink by removing
      existing elements (\<remove>, \<removeAll>, \<clear>, \<retainAll>, \ldots).
    \item \textbf{Replace (R)}: The collection can replace existing
      elements with new values at specific locations/keys (\<set>, \<replaceAll>,
      \<setValue>, \ldots).
\end{itemize}

To run the Modifiability Checker:

\begin{Verbatim}
javac -processor org.checkerframework.checker.modifiability.ModifiabilityChecker MyFile.java
\end{Verbatim}


\sectionAndLabel{Modifiability annotations}{modifiability-annotations}

Figure~\ref{fig-modifiability-lattice} shows the type qualifiers of the
Modifiability Checker.

% TODO: add a figure that follows the sturucture of other checker manuals.
\begin{figure}
  \centering
  \begin{minipage}{0.8\linewidth}
\begin{verbatim}
                    @UnknownModifiability
                      (@Unmodifiable)
                    /        |         \
                   /         |           \
           @Growable    @Shrinkable     @Replaceable
               |     \   /         \   /      |
               |       x             x        |
               |     /   \         /   \      |
           @GrowShrink  @GrowReplace   @ShrinkReplace
                  \          |            /
                   \         |           /
                    \        |          /
                        @Modifiable
\end{verbatim}
  \end{minipage}
  \caption{Modifiability qualifier hierarchy.}
  \label{fig-modifiability-lattice}
\end{figure}

\begin{description}

\item[\refqualclass{checker/modifiability/qual}{UnknownModifiability}]
The checker does not know whether the
collection is modifiable or unmodifiable; it might be either.
The top qualifier in the hierarchy, and it is the default
qualifier that is applied to unannotated collection types.

\item[\refqualclass{checker/modifiability/qual}{Unmodifiable}]
The collection is definitely unmodifiable.  The checker treats it
identically to \code{@UnknownModifiability}, but the different
name is useful for documentation purposes.

\item[\refqualclass{checker/modifiability/qual}{Modifiable}]
Calling mutating operations such as \code{add}, \code{remove},
\code{clear}, etc. on this collection will not result in throwing
\code{UnsupportedOperationException}.

\item[\refqualclass{checker/modifiability/qual}{Growable}]
Calling grow operations such as \code{add}, \code{addAll}, etc. on this
collection will not result in throwing
\code{UnsupportedOperationException}.
Calling shrink or replace operations might or might not result in
throwing \code{UnsupportedOperationException}.

\item[\refqualclass{checker/modifiability/qual}{Shrinkable}]
Calling shrink operations such as \code{remove}, \code{clear}, etc. on this
collection will not result in throwing
\code{UnsupportedOperationException}.
Calling grow or replace operations might or might not result in
throwing \code{UnsupportedOperationException}.

\item[\refqualclass{checker/modifiability/qual}{Replaceable}]
Calling replace operations such as \code{set}, \code{replaceAll}, etc. on
this collection will not result in throwing
\code{UnsupportedOperationException}.
Calling grow or shrink operations might or might not result in
throwing \code{UnsupportedOperationException}.

\item[\refqualclass{checker/modifiability/qual}{GrowShrink}]
Calling grow and shrink operations on this collection will not result in
throwing \code{UnsupportedOperationException}.
Calling replace operations might or might not result in
throwing \code{UnsupportedOperationException}.

\item[\refqualclass{checker/modifiability/qual}{GrowReplace}]
Calling grow and replace operations on this collection will not result in
throwing \code{UnsupportedOperationException}.
Calling shrink operations might or might not result in
throwing \code{UnsupportedOperationException}.

\item[\refqualclass{checker/modifiability/qual}{ShrinkReplace}]
Calling shrink and replace operations on this collection will not result in
throwing \code{UnsupportedOperationException}.
Calling grow operations might or might not result in
throwing \code{UnsupportedOperationException}.

\end{description}

\subsectionAndLabel{Types without grow, shrink, and/or replace methods}{types-without-full-gsr}

There are types that have no methods for certain mutations.

One example is \code{Set}.
The \code{Set} interface does not have replace methods, so
there is no difference between a replaceable \<Set> and an unreplaceable \<Set>.
Likewise, \code{@Modifiable Set} and \code{@GrowShrink Set} mean the same
thing.
For consistency, the Modifiability Checker treats all \code{Set}s as not replaceable.
\begin{itemize}
    \item If a \code{Set} is annotated as \code{@Modifiable}, the
      Modifiability Checker treats it as \code{@GrowShrink}.
    \item If a \code{Set} is annotated as \code{@GrowReplace}, the
      Modifiability Checker changes it to \code{@Growable}.
    \item If a \code{Set} is annotated as \code{@ShrinkReplace}, the
      Modifiability Checker changes it to \code{@Shrinkable}.
    \item If a \code{Set} is annotated as \code{@UnknownModifiability}, the
      checker still reats it as \code{@UnknownModifiability} (no change).
\end{itemize}

Another example is \code{Iterator}. \code{Iterator} only has \code{remove} as an optional method, and growable and replaceable operations do not exist. To maintain consistency, the Modifiability Checker treats all iterators as not replaceable and not growable. Note that \code{ListIterator} is treated normally because it has \code{add} and \code{replace} operations.

Another example is \code{Map.Entry}. \code{Map.Entry} only has
\code{setValue} as an optional method.
To maintain consistency, the Modifiability Checker treats all \code{Map.Entry} objects as not growable and not shrinkable.

\subsectionAndLabel{Polymorphic Types}{modifiability-polymorphic}

Polymorphic annotations serve as method contracts ensuring that the output type retains specific capability bits from the input type (or receiver).

\begin{description}
\item[\code{@PolyModifiable}]
    Full Preservation. Output capabilities (G, S, R) exactly match the Input. Used by strict wrappers like \code{Collections.synchronizedList}.
\item[\code{@PolyShrink}]
    Shrink Preservation. Output retains the \textbf{S} bit of the Input. G and R are fixed or determined separately.
\end{description}

\subsectionAndLabel{Modifiability method annotations}{modifiability-method-annotations}

The Modifiability Checker supports annotation that specify method
behavior.  These are declaration annotations, not type annotations:  they
apply to the method itself rather than to some particular type.

\begin{description}

\item[\refqualclass{checker/modifiability/qual}{ThrowsUOE}]
This is a declaration annotation (not a type qualifier) that is applied to
method and constructor declarations.  It indicates that the method always throws
\code{UnsupportedOperationException}.  The Modifiability Checker issues an
error for any call to a method annotated with \code{@ThrowsUOE}.

\end{description}

% TODO:
% Each annotationâ€™s Javadoc should include a precise description and an example
% use, and should link back to this chapter using
% \code{@checker\_framework.manual \#modifiability-checker Modifiability Checker}.

\sectionAndLabel{What the Modifiability Checker checks}{modifiability-rules}

The Modifiability Checker enforces that mutating methods are only called on
collections that have the required modifiability capability.

A \emph{mutating method} is any method that may change the size or contents of a
collection.
When annotating a method signature, the \textbf{receiver} (\code{this}) must be annotated with the minimum capabilities (G, S, R bits) required to perform the operation.

\begin{itemize}
    \item \textbf{Grow (G)}: If the method increases the size of the collection, the receiver requires \code{@Growable} (G=1).
    Examples: \code{add}, \code{addAll}, \code{offer}, \code{addFirst}, \code{addLast}, \code{ListIterator.add}.

    \item \textbf{Shrink (S)}: If the method decreases the size (or removes elements), the receiver requires \code{@Shrinkable} (S=1).
    Examples: \code{remove}, \code{removeAll}, \code{retainAll}, \code{clear}, \code{poll}, \code{pop}, \code{Iterator.remove}.

    \item \textbf{Replace (R)}: If the method updates an existing element \emph{at a specific location/key}, the receiver requires \code{@Replaceable} (R=1).
    Examples: \code{List.set}, \code{ListIterator.set}, \code{Map.replace}, \code{Map.replaceAll}, \code{Collections.sort}, \code{Map.Entry.setValue}.

    \item \textbf{Combined Requirements}:
    \begin{itemize}
        \item \code{Map.put(K, V)}: Can grow OR replace. Requirement: \code{@GrowReplace} (G=1, R=1).
        \item \code{Map.compute(...)} / \code{merge(...)}: Can grow, shrink, or replace. Requirement: \code{@Modifiable} (G=1, S=1, R=1).
    \end{itemize}

    \item \textbf{Read-Only Operations}: If the method does not modify the structure or elements of the collection, no specific capabilities are required. The receiver can be \code{@UnknownModifiability}.
    Examples: \code{get}, \code{contains}, \code{size}, \code{isEmpty}.
\end{itemize}

\sectionAndLabel{Examples}{modifiability-examples}

\begin{Verbatim}
import java.util.*;
import org.checkerframework.checker.modifiability.qual.*;

class Demo {

    void basicUsage() {
        @Modifiable List<String> mod = new ArrayList<>();
        mod.add("a");     // OK: @Modifiable implies G=1, S=1, R=1
        mod.remove("a");  // OK
        mod.set(0, "b");  // OK

        @Unmodifiable List<String> unmod = List.of("a", "b");
        unmod.add("c");   // Error: receiver requires @Growable, found @Unmodifiable
        unmod.get(0);     // OK: read-only access matches any capability
    }

    void fineGrainedPermissions(@Growable List<String> g,
                                @Shrinkable List<String> s,
                                @Replaceable List<String> r) {
        // Growable list allows adding elements (G=1)
        g.add("a");       // OK
        g.remove("a");    // Error: remove requires @Shrinkable
        g.set(0, "b");    // Error: set requires @Replaceable

        // Shrinkable list allows removing elements (S=1)
        s.remove("a");    // OK
        s.add("a");       // Error: add requires @Growable

        // Replaceable list allows updating elements (R=1)
        r.set(0, "b");    // OK
        r.add("b");       // Error: add requires @Growable
    }

    void combinedPermissions(@GrowReplace Map<String, String> map) {
        // Map.put requires both Grow and Replace capabilities (G=1, R=1)
        map.put("key", "value");  // OK: receiver is @GrowReplace

        // Map.remove requires Shrink capability (S=1)
        map.remove("key");        // Error: receiver is @GrowReplace,
                                  //        but remove requires @Shrinkable
    }

    // Polymorphism preserves capabilities
    @PolyModifiable List<String> process(@PolyModifiable List<String> list) {
        return list.subList(0, 1);
    }
}
\end{Verbatim}

% LocalWords:  Modifiability modifiability copyOf emptyList emptySet gsr
% LocalWords:  emptyMap unmodifiableList unmodifiableSet unmodifiableMap
% LocalWords:  toArray addAll removeAll retainAll replaceAll setValue
% LocalWords:  UnknownModifiability Growable GrowShrink GrowReplace
% LocalWords:  ShrinkReplace growable ListIterator PolyModifiable addFirst
% LocalWords:  synchronizedList PolyShrink ThrowsUOE addLast
