\chapterAndLabel{Modifiability Checker}{modifiability-checker}

In Java, an \emph{optional} method is one that a class may or may not
support.  If the subclass does not support the method, then calling the
method throws \<UnsupportedOperationException>.  Thus, whenever a client
calls an optional method, there is a possibility of an exception.  The
Modifiability Checker eliminates that possibility.

If the Modifiability Checker issues no warning, then your program is
guaranteed not to throw \code{UnsupportedOperationException} due to
invoking a mutating method (such as \code{add} or \code{remove}) on an
unmodifiable collection, map, or iterator.  (This chapter generally uses
just ``collection'', for brevity.)

An \emph{unmodifiable collection} is one that throws
\code{UnsupportedOperationException} if a mutating method is called.
The JDK provides many such collections, for example, the results of:
\begin{itemize}
\item
  \sunjavadoc{java.base/java/util/List.html\#of(E...)}{\code{List.of()}},
  \sunjavadoc{java.base/java/util/List.html\#copyOf(java.util.Collection)}{\code{List.copyOf()}}
\item
  \sunjavadoc{java.base/java/util/Set.html\#of(E...)}{\code{Set.of()}},
  \sunjavadoc{java.base/java/util/Set.html\#copyOf(java.util.Collection)}{\code{Set.copyOf()}}
\item
  \sunjavadoc{java.base/java/util/Map.html\#of(K,V,K,V)}{\code{Map.of()}},
  \sunjavadoc{java.base/java/util/Map.html\#copyOf(java.util.Map)}{\code{Map.copyOf()}}
\item
  \sunjavadoc{java/util/Collections.html\#emptyList()}{\code{Collections.emptyList()}}
  \sunjavadoc{java/util/Collections.html\#emptySet()}{\code{Collections.emptySet()}}
  \sunjavadoc{java/util/Collections.html\#emptyMap()}{\code{Collections.emptyMap()}}
\item
  \sunjavadoc{java.base/java/util/Collections.html\#unmodifiableList(java.util.List)}{\code{Collections.unmodifiableList()}}
  \sunjavadoc{java.base/java/util/Collections.html\#unmodifiableSet(java.util.Set)}{\code{Collections.unmodifiableSet()}}
  \sunjavadoc{java.base/java/util/Collections.html\#unmodifiableMap(java.util.Map)}{\code{Collections.unmodifiableMap()}}
\end{itemize}

A \emph{modifiable collection} is one on which mutating methods can be called
without throwing \code{UnsupportedOperationException}.  Many other methods, such
as \code{get}, \code{contains}, \code{isEmpty}, and \code{toArray}, may be
called on any collection, whether modifiable or unmodifiable.

A collection can be modified in three different ways:
\textbf{Grow}, \textbf{Shrink}, and \textbf{Replace}.
\begin{itemize}
    \item \textbf{Grow}: The collection can grow by adding new elements
      (\<add>, \<addAll>, \<offer>, \<addFirst>, \<addLast>, \<ListIterator.add>, \ldots).
    \item \textbf{Shrink}: The collection can shrink by removing
      existing elements (\<remove>, \<removeAll>, \<clear>, \<retainAll>, \<poll>, \<pop>, \<Iterator.remove>,  \ldots).
    \item \textbf{Replace}: The collection can replace existing
      elements with new values at specific locations/keys (\<List.set>, \<Map.replace>, \<Map.replaceAll>,
       \<ListIterator.set>,  \<Collections.sort>, \<Map.Entry.setValue>, \ldots).
\end{itemize}

To run the Modifiability Checker:

\begin{Verbatim}
javac -processor org.checkerframework.checker.modifiability.ModifiabilityChecker MyFile.java
\end{Verbatim}


\sectionAndLabel{Modifiability annotations}{modifiability-annotations}

Figure~\ref{fig-modifiability-lattice} shows the type qualifiers of the
Modifiability Checker.

% TODO: add a figure that follows the sturucture of other checker manuals.
\begin{figure}
  \centering
  \begin{minipage}{0.8\linewidth}
\begin{verbatim}
                    @UnknownModifiability
                      (@Unmodifiable)
                    /        |         \
                   /         |           \
           @Growable    @Shrinkable     @Replaceable
               |     \   /         \   /      |
               |       x             x        |
               |     /   \         /   \      |
           @GrowShrink  @GrowReplace   @ShrinkReplace
                  \          |            /
                   \         |           /
                    \        |          /
                        @Modifiable
\end{verbatim}
  \end{minipage}
  \caption{Modifiability qualifier hierarchy.}
  \label{fig-modifiability-lattice}
\end{figure}

\begin{description}

\item[\refqualclass{checker/modifiability/qual}{UnknownModifiability}]
The checker does not know whether the
collection is modifiable or unmodifiable; it might be either.
The top qualifier in the hierarchy, and it is the default
qualifier that is applied to unannotated collection types.

\item[\refqualclass{checker/modifiability/qual}{Unmodifiable}]
The collection is definitely unmodifiable.  The checker treats it
identically to \code{@UnknownModifiability}, but the different
name is useful for documentation purposes.

\item[\refqualclass{checker/modifiability/qual}{Modifiable}]
Calling mutating operations such as \code{add}, \code{remove},
\code{clear}, etc. on this collection will not result in throwing
\code{UnsupportedOperationException}.

\item[\refqualclass{checker/modifiability/qual}{Growable}]
Calling grow operations such as \code{add}, \code{addAll}, etc. on this
collection will not result in throwing
\code{UnsupportedOperationException}.
Calling shrink or replace operations might or might not result in
throwing \code{UnsupportedOperationException}.

\item[\refqualclass{checker/modifiability/qual}{Shrinkable}]
Calling shrink operations such as \code{remove}, \code{clear}, etc. on this
collection will not result in throwing
\code{UnsupportedOperationException}.
Calling grow or replace operations might or might not result in
throwing \code{UnsupportedOperationException}.

\item[\refqualclass{checker/modifiability/qual}{Replaceable}]
Calling replace operations such as \code{set}, \code{replaceAll}, etc. on
this collection will not result in throwing
\code{UnsupportedOperationException}.
Calling grow or shrink operations might or might not result in
throwing \code{UnsupportedOperationException}.

\item[\refqualclass{checker/modifiability/qual}{GrowShrink}]
Calling grow and shrink operations on this collection will not result in
throwing \code{UnsupportedOperationException}.
Calling replace operations might or might not result in
throwing \code{UnsupportedOperationException}.

\item[\refqualclass{checker/modifiability/qual}{GrowReplace}]
Calling grow and replace operations on this collection will not result in
throwing \code{UnsupportedOperationException}.
Calling shrink operations might or might not result in
throwing \code{UnsupportedOperationException}.

\item[\refqualclass{checker/modifiability/qual}{ShrinkReplace}]
Calling shrink and replace operations on this collection will not result in
throwing \code{UnsupportedOperationException}.
Calling grow operations might or might not result in
throwing \code{UnsupportedOperationException}.

\end{description}

\subsectionAndLabel{Types without grow, shrink, and/or replace methods}{types-without-full-gsr}

There are types that have no methods for certain mutations.

One example is \code{Set}.
The \code{Set} interface does not have replace methods, so
there is no difference between a replaceable \<Set> and an unreplaceable \<Set>:
\code{@Modifiable Set} and \code{@GrowShrink Set} mean the same
thing.
For consistency, the Modifiability Checker treats all \code{Set}s as not replaceable.
\begin{itemize}
    \item If a \code{Set} is annotated as \code{@Modifiable}, the
      Modifiability Checker treats it as \code{@GrowShrink}.
    \item If a \code{Set} is annotated as \code{@GrowReplace}, the
      Modifiability Checker changes it to \code{@Growable}.
    \item If a \code{Set} is annotated as \code{@ShrinkReplace}, the
      Modifiability Checker changes it to \code{@Shrinkable}.
    \item If a \code{Set} is annotated as \code{@UnknownModifiability}, the
      checker still treats it as \code{@UnknownModifiability} (no change).
\end{itemize}

Another example is \code{Iterator}. \code{Iterator} has the optional
\code{remove} method, but no growth or replacement operations.
For consistency, the Modifiability Checker treats all iterators as not
replaceable and not growable.  Note that \code{ListIterator} is treated
normally because it has optional \code{add} and \code{set} operations.

Another example is \code{Map.Entry}. \code{Map.Entry} has the optional
\code{setValue} method.
The Modifiability Checker treats all \code{Map.Entry} objects as not growable and not shrinkable.

\subsectionAndLabel{Polymorphic Types}{modifiability-polymorphic}

A polymorphic annotations specifies that a method's return type has the
same modifiability as one or more formal parameter types (possibly
including the receiver).

\begin{description}
\item[\refqualclass{checker/modifiability/qual}{PolyModifiable}]
    Full Preservation. Growability, shrinkability, and replacability of the
    return type match those of whichever formal parameter is annotated as
    \<@PolyModifiable>.
    Used by strict wrappers like \code{Collections.synchronizedList}.
\item[\refqualclass{checker/modifiability/qual}{PolyShrink}]
    Shrink Preservation. The return type has the same shrinkability as the
    annotated formal parameter.  The growability and shrinkability are
    determined by non-polymorphic qualifiers from
    Figure~\ref{fig-modifiability-lattice}.

   If \code{@PolyShrink} is the only modifiability qualifier present on a return
type, the capabilities for Grow and Replace default to not guaranteed. The Shrink capability is dynamically determined by the
argument.

For example, consider the method:
\begin{Verbatim}
    @PolyShrink Set<K> keySet(@PolyShrink Map<K, V> self)
\end{Verbatim}

The resulting type of the returned set depends on the input map as follows:
\begin{itemize}
    \item If the map is \code{@Modifiable}, \code{@ShrinkReplace}, \code{@GrowShrink}, or \code{@Shrinkable} the returned set is
    \code{@Shrinkable}.
    \item If the map is \code{@Growable}, \code{@GrowReplace}, \code{@Replaceable} or \code{@Unmodifiable}, the returned set is
    \code{@Unmodifiable}.
\end{itemize}

If both a polymorphic qualifier and a non-polymorphic qualifier are specified on
a return type, the capabilities are additive. The non-polymorphic
qualifier defines the base capabilities (the ``floor'') guaranteed for the
return type, while the polymorphic qualifier preserves the specific shrink
capability from the argument.

For example, a method annotated with \code{@PolyShrink @Growable} returns
a \code{@GrowShrink} collection if the argument is \code{@Shrinkable},
but returns a \code{@Growable} collection if the argument is
\code{@Unmodifiable}. If a return type is annotated with both
\code{@PolyShrink} and \code{@Modifiable}, the \code{@PolyShrink}
annotation is redundant because \code{@Modifiable} already guarantees
shrinkability.

\end{description}

\subsectionAndLabel{Modifiability method annotations}{modifiability-method-annotations}

The Modifiability Checker supports one annotation that specify method
behavior.  This is a declaration annotation, not a type annotation:  it
applies to the method itself rather than to some particular type.

\begin{description}

\item[\refqualclass{checker/modifiability/qual}{ThrowsUOE}]
This is a declaration annotation (not a type qualifier) that is applied to
method and constructor declarations.  It indicates that the method always throws
\code{UnsupportedOperationException}.  (Therefore, any code that call it is
erroneous.)  The Modifiability Checker issues an error at every call to a
method annotated with \code{@ThrowsUOE}.

\end{description}



\sectionAndLabel{Examples}{modifiability-examples}

\begin{Verbatim}
import java.util.*;
import org.checkerframework.checker.modifiability.qual.*;

class Demo {

  void basicUsage() {
    @Modifiable List<String> mod = new ArrayList<>();
    mod.add("a");     // OK: @Modifiable implies G=1, S=1, R=1
    mod.remove("a");  // OK
    mod.set(0, "b");  // OK

    @Unmodifiable List<String> unmod = List.of("a", "b");
    unmod.add("c");   // Error: receiver requires @Growable, found @Unmodifiable
    unmod.get(0);     // OK: read-only access matches any capability
  }

  void fineGrainedPermissions(@Growable List<String> g,
                              @Shrinkable List<String> s,
                              @Replaceable List<String> r) {
    // Growable list allows adding elements (G=1)
    g.add("a");       // OK
    g.remove("a");    // Error: remove requires @Shrinkable
    g.set(0, "b");    // Error: set requires @Replaceable

    // Shrinkable list allows removing elements (S=1)
    s.remove("a");    // OK
    s.add("a");       // Error: add requires @Growable

    // Replaceable list allows updating elements (R=1)
    r.set(0, "b");    // OK
    r.add("b");       // Error: add requires @Growable
  }

  void combinedPermissions(@GrowReplace Map<String, String> map) {
    // Map.put requires both Grow and Replace capabilities (G=1, R=1)
    map.put("key", "value");  // OK: receiver is @GrowReplace

    // Map.remove requires Shrink capability (S=1)
    map.remove("key");        // Error: receiver is @GrowReplace,
                              //        but remove requires @Shrinkable
  }

  // Polymorphism preserves capabilities
  @PolyModifiable List<String> process(@PolyModifiable List<String> list) {
    return list.subList(0, 1);
  }
}
\end{Verbatim}

% LocalWords:  Modifiability modifiability copyOf emptyList emptySet gsr
% LocalWords:  emptyMap unmodifiableList unmodifiableSet unmodifiableMap
% LocalWords:  toArray addAll removeAll retainAll replaceAll setValue
% LocalWords:  UnknownModifiability Growable GrowShrink GrowReplace
% LocalWords:  ShrinkReplace growable ListIterator PolyModifiable addFirst
% LocalWords:  synchronizedList PolyShrink ThrowsUOE addLast unreplaceable
% LocalWords:  Growability shrinkability replacability growability
