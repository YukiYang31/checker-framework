\chapterAndLabel{Modifiability Checker}{modifiability-checker}

In Java, an \emph{optional} method is one that a class may or may not
support.  If the subclass does not support the method, then calling the
method throws \<UnsupportedOperationException>.  Thus, whenever a client
calls an optional method, there is a possibility of an exception.  The
Modifiability Checker eliminates that possibility.

If the Modifiability Checker issues no warning, then your program is
guaranteed not to throw \code{UnsupportedOperationException} due to
invoking a mutating method (such as \code{add} or \code{remove}) on an
unmodifiable collection, map, or iterator.  (This chapter generally uses
just ``collection'', for brevity.)

An \emph{unmodifiable collection} is one that throws
\code{UnsupportedOperationException} if a mutating method is called.
The JDK provides many such collections, for example, the results of:
\begin{itemize}
\item
  \sunjavadoc{java.base/java/util/List.html\#of(E...)}{\code{List.of()}},
  \sunjavadoc{java.base/java/util/List.html\#copyOf(java.util.Collection)}{\code{List.copyOf()}}
\item
  \sunjavadoc{java.base/java/util/Set.html\#of(E...)}{\code{Set.of()}},
  \sunjavadoc{java.base/java/util/Set.html\#copyOf(java.util.Collection)}{\code{Set.copyOf()}}
\item
  \sunjavadoc{java.base/java/util/Map.html\#of(K,V,K,V)}{\code{Map.of()}},
  \sunjavadoc{java.base/java/util/Map.html\#copyOf(java.util.Map)}{\code{Map.copyOf()}}
\item
  \sunjavadoc{java/util/Collections.html\#emptyList()}{\code{Collections.emptyList()}}
  \sunjavadoc{java/util/Collections.html\#emptySet()}{\code{Collections.emptySet()}}
  \sunjavadoc{java/util/Collections.html\#emptyMap()}{\code{Collections.emptyMap()}}
\item
  \sunjavadoc{java.base/java/util/Collections.html\#unmodifiableList(java.util.List)}{\code{Collections.unmodifiableList()}}
  \sunjavadoc{java.base/java/util/Collections.html\#unmodifiableSet(java.util.Set)}{\code{Collections.unmodifiableSet()}}
  \sunjavadoc{java.base/java/util/Collections.html\#unmodifiableMap(java.util.Map)}{\code{Collections.unmodifiableMap()}}
\end{itemize}

A \emph{modifiable collection} is one on which mutating methods can be called
without throwing \code{UnsupportedOperationException}.  Many other methods, such
as \code{get}, \code{contains}, \code{isEmpty}, and \code{toArray}, may be
called on any collection, whether modifiable or unmodifiable.

A collection can be modified in three different ways:
\textbf{Grow}, \textbf{Shrink}, and \textbf{Replace}.
\begin{itemize}
    \item \textbf{Grow}: The collection can grow by adding new elements
      (\<add>, \<addAll>, \<offer>, \<addFirst>, \<addLast>, \<ListIterator.add>, \ldots).
    \item \textbf{Shrink}: The collection can shrink by removing
      existing elements (\<remove>, \<removeAll>, \<clear>, \<retainAll>, \<poll>, \<pop>, \<Iterator.remove>,  \ldots).
    \item \textbf{Replace}: The collection can replace existing
      elements with new values at specific locations/keys (\<List.set>, \<Map.replace>, \<Map.replaceAll>,
       \<ListIterator.set>,  \<Collections.sort>, \<Map.Entry.setValue>, \ldots).
\end{itemize}

To run the Modifiability Checker:

\begin{Verbatim}
javac -processor org.checkerframework.checker.modifiability.ModifiabilityChecker MyFile.java
\end{Verbatim}


\sectionAndLabel{Modifiability annotations}{modifiability-annotations}

The Modifiability Checker uses \textbf{three independent 2-element
hierarchies}, one per capability.  Every annotated type carries exactly
one qualifier from each hierarchy.

% TODO: add a figure that follows the sturucture of other checker manuals.
\begin{figure}
  \centering
  \begin{minipage}{0.85\linewidth}
\begin{verbatim}
  Grow hierarchy        Shrink hierarchy      Replace hierarchy

  @UnknownGrow          @UnknownShrink        @UnknownReplace
       |                      |                      |
  @Growable             @Shrinkable           @Replaceable
\end{verbatim}
  \end{minipage}
  \caption{The three independent Modifiability qualifier hierarchies.
    Each annotated type carries one qualifier from each hierarchy.}
  \label{fig-modifiability-lattice}
\end{figure}

Figure~\ref{fig-modifiability-lattice} shows the three hierarchies.
An assignment \code{T x = y} is valid only if the type of \code{y} is a
subtype of \code{T} in \emph{every} hierarchy simultaneously.  For
example, \code{@Growable @UnknownShrink @UnknownReplace List} is a
subtype of \code{@UnknownGrow @UnknownShrink @UnknownReplace List}
(because \<@Growable> $\le$ \<@UnknownGrow>), but it is \emph{not} a
subtype of \code{@Growable @Shrinkable @UnknownReplace List} (because
\<@UnknownShrink> $\not\le$ \<@Shrinkable>).

\subsectionAndLabel{Hierarchy qualifiers}{modifiability-hierarchy-qualifiers}

\begin{description}

\item[\refqualclass{checker/modifiability/qual}{UnknownGrow}]
The top qualifier in the Grow hierarchy.
The checker cannot determine whether this collection supports grow
operations.  This is the default qualifier for unannotated types in the
Grow hierarchy.

\item[\refqualclass{checker/modifiability/qual}{Growable}]
The bottom qualifier in the Grow hierarchy.
Calling grow operations such as \code{add}, \code{addAll}, etc.\ on this
collection will not result in throwing \code{UnsupportedOperationException}.
No guarantees are made about shrink or replace operations.

\item[\refqualclass{checker/modifiability/qual}{UnknownShrink}]
The top qualifier in the Shrink hierarchy.
The checker cannot determine whether this collection supports shrink
operations.  This is the default qualifier for unannotated types in the
Shrink hierarchy.

\item[\refqualclass{checker/modifiability/qual}{Shrinkable}]
The bottom qualifier in the Shrink hierarchy.
Calling shrink operations such as \code{remove}, \code{clear}, etc.\ on
this collection will not result in throwing
\code{UnsupportedOperationException}.
No guarantees are made about grow or replace operations.

\item[\refqualclass{checker/modifiability/qual}{UnknownReplace}]
The top qualifier in the Replace hierarchy.
The checker cannot determine whether this collection supports replace
operations.  This is the default qualifier for unannotated types in the
Replace hierarchy.

\item[\refqualclass{checker/modifiability/qual}{Replaceable}]
The bottom qualifier in the Replace hierarchy.
Calling replace operations such as \code{set}, \code{replaceAll}, etc.\
on this collection will not result in throwing
\code{UnsupportedOperationException}.
No guarantees are made about grow or shrink operations.

\end{description}

\subsectionAndLabel{Combining capabilities}{modifiability-combining}

To express multiple capabilities, write one annotation per hierarchy:

\begin{Verbatim}
  @Growable @Shrinkable List<String>   // can grow and shrink, replace unknown
  @Growable @Replaceable List<String>  // can grow and replace, shrink unknown
  @Growable @Shrinkable @Replaceable List<String>  // all three capabilities
\end{Verbatim}

Because the three hierarchies are independent, subtyping checks each
hierarchy individually.  A \code{@Growable @Shrinkable List} is a
subtype of \code{@Growable List} (Shrink information is dropped, Replace
defaults to \<@UnknownReplace> on both sides), but it is \emph{not} a
subtype of \code{@Growable @Shrinkable @Replaceable List} (the Replace
hierarchy differs).

\subsectionAndLabel{Alias annotations}{modifiability-aliases}

For convenience, the Modifiability Checker provides four alias
annotations.  They are not part of any hierarchy; the checker expands
each one into its constituent qualifiers when it appears in source code.

\begin{description}

\item[\refqualclass{checker/modifiability/qual}{Modifiable}]
Alias for \code{@Growable @Shrinkable @Replaceable}.
Calling any mutating operation on this collection will not throw
\code{UnsupportedOperationException}.

\item[\refqualclass{checker/modifiability/qual}{Unmodifiable}]
Alias for \code{@UnknownGrow @UnknownShrink @UnknownReplace}.
The collection is definitely unmodifiable: calling any mutating operation
always throws \code{UnsupportedOperationException}.

\item[\refqualclass{checker/modifiability/qual}{UnknownModifiability}]
Alias for \code{@UnknownGrow @UnknownShrink @UnknownReplace}.
The checker cannot determine the modifiability of the collection.
Equivalent to \<@Unmodifiable>.

\item[\refqualclass{checker/modifiability/qual}{PolyModifiable}]
Alias for \code{@PolyGrow @PolyShrink @PolyReplace}
(see Section~\ref{modifiability-polymorphic}).

\end{description}

\noindent
Examples using alias annotations:

\begin{Verbatim}
  @Modifiable List<String> mod = new ArrayList<>();  // all three capabilities
  @Unmodifiable List<String> unmod = List.of("a");   // no capabilities
  @UnknownModifiability List<String> unknown = ...;  // same as @Unmodifiable
\end{Verbatim}


\subsectionAndLabel{Types without grow, shrink, and/or replace methods}{types-without-full-gsr}

Some Java types lack methods for certain kinds of mutation.  The
Modifiability Checker automatically removes capabilities that the type
cannot support.

\paragraph{Set and Queue (except LinkedList).}
The \code{Set} interface has no replace methods (\code{set} is a
\code{List}-only operation).  Similarly, \code{Queue} has no replace
methods in general.  The Modifiability Checker therefore sets the
Replace hierarchy qualifier to \<@UnknownReplace> for any \code{Set} or
non-\code{LinkedList} \code{Queue}, regardless of what is written on the
type.  For example:

\begin{itemize}
    \item \code{@Growable @Shrinkable @Replaceable Set} $\Rightarrow$
      treated as \code{@Growable @Shrinkable @UnknownReplace Set}
    \item \code{@Growable @Replaceable Set} $\Rightarrow$
      treated as \code{@Growable @UnknownShrink @UnknownReplace Set}
    \item \code{@Growable @Shrinkable Set} $\Rightarrow$ unchanged
      (\<@UnknownReplace> is already the default)
\end{itemize}

\paragraph{Map.Entry.}
\code{Map.Entry} has only the optional \code{setValue} method (a
replace operation) and no grow or shrink operations.  The Modifiability
Checker therefore sets the Grow and Shrink hierarchy qualifiers to
\<@UnknownGrow> and \<@UnknownShrink> respectively.  For example:

\begin{itemize}
    \item \code{Map.@Growable @Shrinkable @Replaceable Entry} $\Rightarrow$
      treated as \code{Map.@UnknownGrow @UnknownShrink @Replaceable Entry}
    \item \code{Map.@Growable Entry} $\Rightarrow$
      treated as \code{Map.@UnknownGrow @UnknownShrink @UnknownReplace Entry}
\end{itemize}

\paragraph{Iterator.}
\code{Iterator} has only the optional \code{remove} method (a shrink
operation) and no grow or replace operations.  (Note that
\code{ListIterator} is treated normally because it also has optional
\code{add} and \code{set} operations.)  The Modifiability Checker
therefore sets the Grow and Replace hierarchy qualifiers to
\<@UnknownGrow> and \<@UnknownReplace>:

\begin{itemize}
    \item \code{@Growable @Shrinkable @Replaceable Iterator} $\Rightarrow$
      treated as \code{@UnknownGrow @Shrinkable @UnknownReplace Iterator}
    \item \code{@Growable Iterator} $\Rightarrow$
      treated as \code{@UnknownGrow @UnknownShrink @UnknownReplace Iterator}
\end{itemize}


\subsectionAndLabel{Polymorphic qualifiers}{modifiability-polymorphic}

A polymorphic qualifier specifies that a method's return type has the
same qualifier (in some hierarchy) as a formal parameter type (possibly
the receiver).

\begin{description}

\item[\refqualclass{checker/modifiability/qual}{PolyGrow}]
Polymorphic qualifier for the Grow hierarchy.
The return type's Grow qualifier matches the Grow qualifier of whichever
formal parameter is annotated with \<@PolyGrow>.

\item[\refqualclass{checker/modifiability/qual}{PolyShrink}]
Polymorphic qualifier for the Shrink hierarchy.
The return type's Shrink qualifier matches the Shrink qualifier of
whichever formal parameter is annotated with \<@PolyShrink>.
Useful for methods such as \code{Map.keySet()} that strip Grow and
Replace but preserve Shrink.

\item[\refqualclass{checker/modifiability/qual}{PolyReplace}]
Polymorphic qualifier for the Replace hierarchy.
The return type's Replace qualifier matches the Replace qualifier of
whichever formal parameter is annotated with \<@PolyReplace>.

\item[\refqualclass{checker/modifiability/qual}{PolyModifiable}]
Alias for \code{@PolyGrow @PolyShrink @PolyReplace}.
Preserves all three capabilities simultaneously.
Use on methods such as \code{Collections.synchronizedList} that are pure
wrappers and do not change modifiability.

\end{description}

\noindent
Because the three poly qualifiers are independent, you can mix
polymorphic and concrete qualifiers across hierarchies.  For example:

\begin{Verbatim}
  // Shrink is preserved from the map; Grow and Replace are not.
  @PolyShrink Set<K> keySet(@PolyShrink Map<K, V> map)
\end{Verbatim}

If the map is \code{@Growable @Shrinkable @UnknownReplace}, then
\code{keySet} returns \code{@UnknownGrow @Shrinkable @UnknownReplace Set}
(after the Modifiability Checker also strips Replace from the \code{Set}
return type, which was already \<@UnknownReplace>).

If the map is \code{@Growable @UnknownShrink @UnknownReplace}, then
\code{keySet} returns \code{@UnknownGrow @UnknownShrink @UnknownReplace Set}.


\subsectionAndLabel{Modifiability method annotations}{modifiability-method-annotations}

The Modifiability Checker supports one annotation that specifies method
behavior.  This is a declaration annotation, not a type annotation: it
applies to the method itself rather than to some particular type.

\begin{description}

\item[\refqualclass{checker/modifiability/qual}{ThrowsUOE}]
This is a declaration annotation (not a type qualifier) that is applied to
method and constructor declarations.  It indicates that the method always throws
\code{UnsupportedOperationException}.  (Therefore, any code that calls it is
erroneous.)  The Modifiability Checker issues an error at every call to a
method annotated with \code{@ThrowsUOE}.

\end{description}



\sectionAndLabel{Examples}{modifiability-examples}

\begin{Verbatim}
import java.util.*;
import org.checkerframework.checker.modifiability.qual.*;

class Demo {

  void basicUsage() {
    // @Modifiable is an alias for @Growable @Shrinkable @Replaceable
    @Modifiable List<String> mod = new ArrayList<>();
    mod.add("a");     // OK: @Growable guarantees add() works
    mod.remove("a");  // OK: @Shrinkable guarantees remove() works
    mod.set(0, "b");  // OK: @Replaceable guarantees set() works

    // @Unmodifiable is an alias for @UnknownGrow @UnknownShrink @UnknownReplace
    @Unmodifiable List<String> unmod = List.of("a", "b");
    unmod.add("c");   // Error: add() requires @Growable, got @UnknownGrow
    unmod.get(0);     // OK: read-only access needs no capability
  }

  void fineGrainedPermissions(@Growable List<String> g,
                              @Shrinkable List<String> s,
                              @Replaceable List<String> r) {
    // Growable list allows adding elements
    g.add("a");       // OK
    g.remove("a");    // Error: remove() requires @Shrinkable
    g.set(0, "b");    // Error: set() requires @Replaceable

    // Shrinkable list allows removing elements
    s.remove("a");    // OK
    s.add("a");       // Error: add() requires @Growable

    // Replaceable list allows updating elements
    r.set(0, "b");    // OK
    r.add("b");       // Error: add() requires @Growable
  }

  void combinedPermissions(@Growable @Replaceable Map<String, String> map) {
    // Map.put requires both Grow and Replace capabilities
    map.put("key", "value");  // OK

    // Map.remove requires Shrink capability
    map.remove("key");        // Error: @UnknownShrink (default) !<: @Shrinkable
  }

  // @PolyModifiable preserves all three capabilities
  @PolyModifiable List<String> wrap(@PolyModifiable List<String> list) {
    return list;
  }

  void testPoly(@Modifiable List<String> mod, @Growable @Shrinkable List<String> gs) {
    @Modifiable List<String> m = wrap(mod);            // OK
    @Growable @Shrinkable List<String> gs2 = wrap(gs); // OK
    // :: error: (assignment)
    @Modifiable List<String> bad = wrap(gs);  // Error: gs has @UnknownReplace
  }
}
\end{Verbatim}

% LocalWords:  Modifiability modifiability copyOf emptyList emptySet gsr
% LocalWords:  emptyMap unmodifiableList unmodifiableSet unmodifiableMap
% LocalWords:  toArray addAll removeAll retainAll replaceAll setValue
% LocalWords:  UnknownModifiability Growable UnknownGrow UnknownShrink
% LocalWords:  UnknownReplace growable ListIterator PolyModifiable addFirst
% LocalWords:  synchronizedList PolyShrink PolyGrow PolyReplace ThrowsUOE
% LocalWords:  addLast unreplaceable Growability shrinkability replacability
% LocalWords:  growability Shrinkable Replaceable
